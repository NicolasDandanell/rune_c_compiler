use crate::RuneFileDescription;
use crate::c_utilities::{ CStructMember, pascal_to_snake_case, pascal_to_uppercase, spaces };
use crate::output_file::OutputFile;
use rune_parser::types::{ FieldSlot, FieldType, StructMember, UserDefinitionLink};
use std::path::Path;

pub fn output_source(file: &RuneFileDescription, output_path: &Path) {

    // Print disclaimers. Requires C23 compliant compiler
    //
    // · Autogenerated code info
    //
    // · Compiler version (C23 compliant)
    //
    // GCC 13 or higher
    // CLang 8.0 or higher
    //
    // —————————————————————————————————————————————————

    let c_file_string: String = format!("{0}{1}.rune.c",
        match file.relative_path.is_empty() {
            true  => String::new(),
            false => format!("/{0}", file.relative_path)
        }, file.file_name
    );

    let mut source_file: OutputFile = OutputFile::new(String::from(output_path.to_str().unwrap()), c_file_string);

    // Disclaimers
    // ————————————

    // ...

    // Include own header
    // ———————————————————

    source_file.add_line(format!("#include \"{0}.rune.h\"", file.file_name));
    source_file.add_newline();

    // Include rune.h
    // ———————————————

    source_file.add_line(format!("#include \"rune.h\""));

    // Struct parsers
    // ———————————————

    for struct_definition in &file.definitions.structs {

        // println!("Parsing {0}", struct_definition.name);

        let struct_name: String = pascal_to_snake_case(&struct_definition.name);

        // SORT BY INDEX; DO NOT FORGET
        // INDEXES MISSING MUST HAVE AN EMPTY DEFINITION --> .size = 0 will cause the field to be skipped

        // Get highest index number (except verification field)
        let mut highest_index: usize   = 0;
        let mut has_verification: bool = false;

        for member in &struct_definition.members {
            let index: usize = match member.field_slot {
                FieldSlot::VerificationField       => { has_verification = true; 0 },
                FieldSlot::NamedSlot(value) => value
            };

            if index > highest_index {
                highest_index = index;
            }
        }

        let member_count: usize = highest_index + 1;

        // Index sort all members, adding empty definitions for skipped fields
        let mut index_sorted_members: Vec<StructMember> = Vec::with_capacity(member_count);

        // Also get longest member name for spacing reasons
        let mut longest_member_name_size: usize = 0;

        for i in 0..member_count  {

            // Empty definition that will be used if index not found in struct list
            let mut member: StructMember = StructMember::index_empty(i);

            // Try to find member with index i
            for listed_member in &struct_definition.members {
                let listed_index: usize = match listed_member.field_slot {
                    FieldSlot::NamedSlot(index) => index,
                    FieldSlot::VerificationField       => 0
                };

                if listed_index == i {
                    member = listed_member.clone();

                    if pascal_to_snake_case(&member.ident).len() > longest_member_name_size {
                        longest_member_name_size = pascal_to_snake_case(&member.ident).len()
                    }
                }
            }

            index_sorted_members.push(member);
        }

        source_file.add_newline();
        source_file.add_line(format!("rune_message_parser_t RUNIC_PARSER {0}_parser = {{", struct_name));
        source_file.add_line(format!("    .size                     = sizeof({0}_t),", struct_name));
        source_file.add_line(format!("    .parsing_data             = {{"));
        source_file.add_line(format!("        .largest_field        = {0},", highest_index));
        source_file.add_line(format!("        .has_verification     = {0},", has_verification));
        source_file.add_line(format!("        .padding /* Unused */ = 0"));
        source_file.add_line(format!("    }},"));

        source_file.add_line(format!("    .field_info               = {{"));

        for i in 0..member_count {
            let member_name: String = pascal_to_snake_case(&index_sorted_members[i].ident);
            let spacing: usize      = longest_member_name_size - member_name.len();

           //  println!("Got spacing {0} from longest member size {1}", spacing, longest_member_name_size);

            let init_char: String = match &index_sorted_members[i].field_type {
                FieldType::Empty => String::new(),
                _                => String::from(".")
            };

            let end: char = match i == member_count - 1 {
                false => ',',
                true  => ' '
            };

            let size_string: String = index_sorted_members[i].c_size_definition();

            let verification_string: String = match has_verification && i == member_count - 1 {
                false => String::from(""),
                true  => String::from(" - Verification field")
            };

            let parser_index_string: String = match &index_sorted_members[i].user_definition_link {
                UserDefinitionLink::StructLink(link) => format!("RUNE_{0}_PARSER_INDEX", pascal_to_uppercase(&link.name)),
                _ => String::from("RUNE_NO_PARSER")
            };

            let offset_string: String = match &index_sorted_members[i].field_type {
                FieldType::Empty => String::from("0"),
                _ => format!("offsetof({0}_t, {1})", struct_name, member_name)
            };

            source_file.add_line(format!("        /* {0}{1}: {2}{3}{4} */ {{", init_char, member_name, spaces(spacing), i, verification_string));
            source_file.add_line(format!("            .field_offset       = {0},", offset_string));
            source_file.add_line(format!("            .field_size         = {0},", size_string));
            source_file.add_line(format!("            .parser_array_index = {0}", parser_index_string));

            source_file.add_line(format!("        }}{0}", end));
        }

        source_file.add_line(format!("    }}"));
        source_file.add_line(format!("}};"));
    }

    source_file.output_file();
}
